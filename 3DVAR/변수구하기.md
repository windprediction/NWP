
# 3DVAR 기반 LDAPS 자료동화 분석 예제

이 문서는 **LDAPS 예측장(배경장)과 가상 AWS 관측값을 이용한 3DVAR 분석 예제**를 보여줍니다.  
KMA LDAPS/UM 3DVAR 시스템의 핵심 원리를 단순화한 형태로 구현되었습니다.

---

## Python 코드

```python
import pandas as pd
import numpy as np
import torch
from scipy.spatial import cKDTree

# --- 1. LDAPS 배경장 CSV 불러오기 ---
df02 = pd.read_csv("2020-01-01_02_00_00.csv")
df03 = pd.read_csv("2020-01-01_03_00_00.csv")
df02["forecast_time"] = "2020-01-01 02:00:00"
df03["forecast_time"] = "2020-01-01 03:00:00"
df_bg = pd.concat([df02, df03], ignore_index=True)

# 필요한 변수만 추출 (LDAPS Grib2 -> CSV 변환 데이터 기반)
bg_vars = df_bg[["latitude", "longitude", "ta_1p5m", "tdp_1p5m", "uws_10m", "vws_10m"]].copy()

# --- 2. 가상 관측 (AWS, 한 지점) ---
aws = pd.DataFrame({"lat":[37.5], "lon":[127.0], "temp":[273.5], "wind":[3.0], "rh":[80]})

# --- 3. 최근접 보간 (H 연산자: 모델 → 관측 변환) ---
def nearest_interp(lat_model, lon_model, field, obs_lats, obs_lons):
    coords = np.vstack([lat_model, lon_model]).T
    tree = cKDTree(coords)
    obs_coords = np.vstack([obs_lats, obs_lons]).T
    if len(obs_coords) == 0:
        return np.array([])  # 관측 없을 때 빈 배열 반환
    _, idx = tree.query(obs_coords)
    return np.array(field[idx])

# LDAPS 2m 기온을 관측점으로 보간
aws_model_temp = nearest_interp(
    bg_vars["latitude"].values,
    bg_vars["longitude"].values,
    bg_vars["ta_1p5m"].values,
    aws["lat"].values,
    aws["lon"].values
)

if aws_model_temp.size == 0:
    raise RuntimeError("모델 필드에서 보간된 값이 없습니다. 좌표 또는 변수명을 확인하세요.")

# --- 4. 배경오차(B), 관측오차(R) 공분산 설정 ---
B = torch.diag(torch.tensor([1.5, 1.0, 2.0]))  # 배경 오차
R = torch.diag(torch.tensor([0.5, 0.3, 1.0]))  # 관측 오차

# --- 5. 3DVAR 목적 함수 정의 ---
def cost_function(x, x_b, y, B, R, H):
    Hx = H(x)
    term1 = (x - x_b).unsqueeze(0) @ torch.inverse(B) @ (x - x_b).unsqueeze(1)
    term2 = (y - Hx).unsqueeze(0) @ torch.inverse(R) @ (y - Hx).unsqueeze(1)
    return 0.5 * (term1 + term2).squeeze()

# 단순 H 연산자 (모델 공간과 관측 공간 동일 가정)
H = lambda z: z

# --- 6. 3DVAR 최적화 수행 ---
y = torch.tensor([aws["temp"][0]-273.15, aws["wind"][0], aws["rh"][0]], dtype=torch.float32)
x_b = torch.tensor([aws_model_temp[0]-273.15, 3.0, 75.0], dtype=torch.float32)

x = x_b.clone().requires_grad_(True)
optimizer = torch.optim.LBFGS([x], lr=0.1, max_iter=50)

def closure():
    optimizer.zero_grad()
    loss = cost_function(x, x_b, y, B, R, H)
    loss.backward()
    return loss

optimizer.step(closure)
x_star = x.detach().numpy()

print("관측(y):", y.numpy())
print("배경장(x_b):", x_b.numpy())
print("분석장(x*):", x_star)
````

---

## 출력 결과 
```
관측(y): [ 0.35  3.   80.  ]
배경장(x_b): [-2.50168  3.      75.     ]
분석장(x*): [-0.3747894   3.         78.31437   ]
```

---

## 결과 해석

### 1. **관측(y)**

`[0.35, 3., 80.]`

* 실제 관측 데이터 (가상 AWS)

  * **0.35°C**: 관측된 2m 기온
  * **3.0 m/s**: 10m 바람
  * **80%**: 상대습도

### 2. **배경장(x\_b)**

`[-2.50168, 3., 75.]`

  * **-2.50°C**: 모델 예측 2m 기온
  * **3.0 m/s**: 모델 예측 바람
  * **75%**: 모델 예측 상대습도

### 3. **분석장(x\*)**

`[-0.3747894, 3., 78.31437]`

* **3DVAR 결과** (배경장과 관측을 최적화로 결합한 값)

  * 기온: 관측 0.35°C, 배경장 -2.50°C → **분석 -0.37°C** (중간값)
  * 바람: 관측과 배경장이 같아 **3.0 m/s 유지**
  * 습도: 관측 80%, 배경장 75% → **분석 78.3%**

---

## 3DVAR 목적 함수

$$
J(x) = \frac{1}{2}(x - x_b)^T B^{-1}(x - x_b) + \frac{1}{2}(y - H(x))^T R^{-1}(y - H(x))
$$

* 첫 번째 항: **모델과의 차이 (배경 오차)**
* 두 번째 항: **관측과의 차이 (관측 오차)**
* **B, R**: 두 항의 가중치 (모델 신뢰도 vs 관측 신뢰도)

---


```


